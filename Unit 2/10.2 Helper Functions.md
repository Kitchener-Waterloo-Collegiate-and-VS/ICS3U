## Lesson: Prime Numbers and Helper Functions

**Prime numbers** are whole numbers greater than 1 whose only positive factors are 1 and itself. Positive numbers that are not prime are called **composite numbers**.

For example, 5 is a prime number since its only positive factors are 1 and 5, and 6 is a composite number since its positive factors are 1, 2, 3, and 6.

Checking whether a number is prime is a common programming practice problem. We can use a **brute force search** to find the factors of a number. Factors are never greater than the original number, so we just need to check all the whole numbers between 2 and the original number. If we find a factor other than 1 or itself, the number is not prime.

```python
def is_prime(n):
  if n < 2:  # 2 is the smallest prime 
    return False
  for i in range(2, n):
    if n % i == 0:  # if i is a factor of n
      return False
  return True  # we didn't find any other factors, so the number must be prime
```

This algorithm works, but there is room for improvement. Here are some examples of factors of positive whole numbers. 

* Factors of 6: 1, 2, 3, 6
* Factors of 15: 1, 3, 5, 15
* Factors of 20: 1, 2, 4, 5, 10, 20
* Factors of 36: 1, 2, 3, 4, 6, 9, 12, 18, 36

Notice that there are usually an even number of factors and they come in pairs. For example, 6 = 1 × 6 and 6 = 2 × 3. The only exception is when the number is square, because the square root is paired with itself: 36 = 6 × 6.

Within each factor pair, the smaller factor is always less than or equal to the square root of the original number, so it turns out we only have to check for factors less than or equal to the square root. If we don't find a factor within that range, there won't be any more factors since they wouldn't have anything to be paired with.

```python
def is_prime(n):
  if n < 2:   
    return False
  sqrt = int(n ** 0.5)
  for i in range(2, sqrt + 1):  # slight modification here
    if n % i == 0:  
      return False
  return True 
```
This may seem like it's not much faster than the original version, but when `n` is a large number, it saves a considerable amount of time.

Can we make this even more efficient? Let's try.

Every composite number can be written as a *unique* factorization of prime numbers.

* Prime factorization of 14: 2 × 7
* Prime factorization of 18: 2 × 2 × 3 × 3
* Prime factorization of 99: 3 × 3 × 11

This is referred to the **Fundamental Theorem of Arithmetic**. It's arguably the most important theorem in arithmetic. It's the main reason why 1 is not consider to be a prime number (otherwise we could multiply each factorization by an unlimited number of 1s and they wouldn't be unique ). This also explains why non-prime numbers are called *composite* numbers. They are *composed* of prime numbers.

Rather than checking every number between 2 and the square root, we only have to check the prime numbers.

One way of doing this is creating a **helper function** that generates prime numbers. A helper function is a function that is created to help another function by making it easier to understand and follow. 

```python
def get_next_prime(list_of_primes):
  if len(list_of_primes) == 0:
    return 2
  next_prime = list_of_primes[-1] + 1
  while True:
    for p in list_of_primes:
      if next_prime % p == 0: # found a composite
        next_prime += 1 # updates next number
        break
      elif next_prime ** 0.5 < p:  # we've made it up to the square root, so we have a prime
        return next_prime

list_of_primes = []

for _ in range(10):
  list_of_primes.append(get_next_prime(list_of_primes))

print(list_of_primes) # prints the first 10 prime numbers
```

To check whether a number is prime, we can use this helper function to keep generating primes until we either spot the number or we pass it.

```python
def is_prime(n):
  list_of_primes = []
  next_prime = get_next_prime(list_of_primes)
  while next_prime <= n:
    if n == next_prime:
      return True  # n is shows up i the list, so its prime
    list_of_primes += [next_prime]
    next_prime = get_next_prime(list_of_primes)
  return False  # n did not show up, so it's composite
    
def get_next_prime(list_of_primes):
  if len(list_of_primes) == 0:
    return 2
  next_prime = list_of_primes[-1] + 1
  while True:
    for p in list_of_primes:
      if next_prime % p == 0: # found a composite
        next_prime += 1 # updates next number
      elif next_prime ** 0.5 < p:  # we've made it up to the square root, so we have a prime
        return next_prime

print(is_prime(2))  # prints True
print(is_prime(3))  # prints True
print(is_prime(4))  # prints False
print(is_prime(5))  # prints True
print(is_prime(39))  # prints False
print(is_prime(67))  # prints True
print(is_prime(91))  # prints False
print(is_prime(997))  # prints True
print(is_prime(100001))  # prints False (but takes several seconds)
```

However, this approach isn't really efficient when we're just checking whether a single number is prime. When we are checking a long list of numbers to determine which ones are prime, we could pre-generate the list of prime numbers so that we don't have to generate it every time we call `is_prime()`. 

```python
def is_prime(n, list_of_primes):
  assert(len(list_of_primes) != 0)
  if n < list_of_primes[-1] < n:
    raise ValueError("The value of n is too large to determine whether it's prime.")
  return n in list_of_primes
    
def get_next_prime(list_of_primes):
  if len(list_of_primes) == 0:
    return 2
  next_prime = list_of_primes[-1] + 1
  while True:
    for p in list_of_primes:
      if next_prime % p == 0: # found a composite
        next_prime += 1 # updates next number
        break
      elif next_prime ** 0.5 < p:  # we've made it up to the square root, so we have a prime
        return next_prime

list_of_primes = []

for _ in range(1000):  # generates the first 1000 prime numbers
  list_of_primes.append(get_next_prime(list_of_primes))

print(is_prime(103, list_of_primes))  # prints True
print(is_prime(119, list_of_primes))  # prints False
print(is_prime(127, list_of_primes))  # prints True
print(is_prime(3067, list_of_primes))  # prints True
print(is_prime(5041, list_of_primes))  # prints False
print(is_prime(7139, list_of_primes))  # prints False
```
