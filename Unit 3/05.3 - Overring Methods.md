### Overriding Methods

If we call `dir()` on a blank custom class, we get the following: 

```python
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
```

We can **override** any of these methods by redefining them within our class.

Here are a few in particular that are useful:

* `__init__()` is the constructor
* `__repr__()` is for printing (`print()`)
* `__eq__()` is for equality (`==`)
* `__sizeof__()` is for length/size (`len()`)

```python
class Enemy:
  def __init__(self, name, attacks, health): # Overriding the constructor
    self.name = name
    self.attacks = attacks
    self.health = health

  def __repr__(self): # Overriding the print operation
    line1 = "Name: " + self.name
    line2 = "\nAttacks: " + str(self.attacks)
    line3 = "\nHealth: " + str(self.health)
    return line1 + line2 + line3
```

The `self` keyword is passed in all methods. Field names begins with `self.` when they are being used in a method in order to distinguish between them from the parameters of the method. Whenever we call any method from the class, we omit the `self` parameter.

```python
ganon = Enemy("Ganon", ["sword", "ice blocks", "tornado", "earthquake"], 100)

''' prints the following:
Name: Ganon
Attacks: ['sword', 'ice blocks', 'tornado', 'earthquake']
Health: 100
'''
print(ganon)  
```
